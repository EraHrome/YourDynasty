/* 
 * Betaface API 2.0
 *
 * Betaface face recognition API.
 *
 * OpenAPI spec version: 2.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using SwaggerDateConverter = IO.Swagger.Client.SwaggerDateConverter;

namespace IO.Swagger.Model
{
    /// <summary>
    /// represents a set person call body parameters.
    /// </summary>
    [DataContract]
    public partial class SetPerson :  IEquatable<SetPerson>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SetPerson" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected SetPerson() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="SetPerson" /> class.
        /// </summary>
        /// <param name="apiKey">your API key or d45fd466-51e2-4701-8da8-04351c872236 (required).</param>
        /// <param name="facesUuids">list of face uuids to set person id. each face can have only one person id assigned to it. setting a person id overwrites the old value. (required).</param>
        /// <param name="personId">person id in format name@namespace. name and namespace can include letters, numbers, dots, underscores and spaces. special name random@namespace could be used to assign random person name with specific namespace. Namespace part should not exceed 60 characters. Name part should not exceed 200 characters. Setting person_id to empty string resets the person id. Faces will be permanently stored for as long as person id is assigned to them. Faces without person ids will be deleted starting from 24 hours. Resetting person id on faces generated more than 24 hours ago may immediately delete the. When face is assigned to/removed from namespace search indexes of namespaces involved will asynchrously update. It may take from seconds to serveral minutes depending on namespace size for changes to propagate..</param>
        public SetPerson(Guid? apiKey = default(Guid?), List<Guid?> facesUuids = default(List<Guid?>), string personId = default(string))
        {
            // to ensure "apiKey" is required (not null)
            if (apiKey == null)
            {
                throw new InvalidDataException("apiKey is a required property for SetPerson and cannot be null");
            }
            else
            {
                this.ApiKey = apiKey;
            }
            // to ensure "facesUuids" is required (not null)
            if (facesUuids == null)
            {
                throw new InvalidDataException("facesUuids is a required property for SetPerson and cannot be null");
            }
            else
            {
                this.FacesUuids = facesUuids;
            }
            this.PersonId = personId;
        }
        
        /// <summary>
        /// your API key or d45fd466-51e2-4701-8da8-04351c872236
        /// </summary>
        /// <value>your API key or d45fd466-51e2-4701-8da8-04351c872236</value>
        [DataMember(Name="api_key", EmitDefaultValue=false)]
        public Guid? ApiKey { get; set; }

        /// <summary>
        /// list of face uuids to set person id. each face can have only one person id assigned to it. setting a person id overwrites the old value.
        /// </summary>
        /// <value>list of face uuids to set person id. each face can have only one person id assigned to it. setting a person id overwrites the old value.</value>
        [DataMember(Name="faces_uuids", EmitDefaultValue=false)]
        public List<Guid?> FacesUuids { get; set; }

        /// <summary>
        /// person id in format name@namespace. name and namespace can include letters, numbers, dots, underscores and spaces. special name random@namespace could be used to assign random person name with specific namespace. Namespace part should not exceed 60 characters. Name part should not exceed 200 characters. Setting person_id to empty string resets the person id. Faces will be permanently stored for as long as person id is assigned to them. Faces without person ids will be deleted starting from 24 hours. Resetting person id on faces generated more than 24 hours ago may immediately delete the. When face is assigned to/removed from namespace search indexes of namespaces involved will asynchrously update. It may take from seconds to serveral minutes depending on namespace size for changes to propagate.
        /// </summary>
        /// <value>person id in format name@namespace. name and namespace can include letters, numbers, dots, underscores and spaces. special name random@namespace could be used to assign random person name with specific namespace. Namespace part should not exceed 60 characters. Name part should not exceed 200 characters. Setting person_id to empty string resets the person id. Faces will be permanently stored for as long as person id is assigned to them. Faces without person ids will be deleted starting from 24 hours. Resetting person id on faces generated more than 24 hours ago may immediately delete the. When face is assigned to/removed from namespace search indexes of namespaces involved will asynchrously update. It may take from seconds to serveral minutes depending on namespace size for changes to propagate.</value>
        [DataMember(Name="person_id", EmitDefaultValue=false)]
        public string PersonId { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class SetPerson {\n");
            sb.Append("  ApiKey: ").Append(ApiKey).Append("\n");
            sb.Append("  FacesUuids: ").Append(FacesUuids).Append("\n");
            sb.Append("  PersonId: ").Append(PersonId).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as SetPerson);
        }

        /// <summary>
        /// Returns true if SetPerson instances are equal
        /// </summary>
        /// <param name="input">Instance of SetPerson to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(SetPerson input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.ApiKey == input.ApiKey ||
                    (this.ApiKey != null &&
                    this.ApiKey.Equals(input.ApiKey))
                ) && 
                (
                    this.FacesUuids == input.FacesUuids ||
                    this.FacesUuids != null &&
                    this.FacesUuids.SequenceEqual(input.FacesUuids)
                ) && 
                (
                    this.PersonId == input.PersonId ||
                    (this.PersonId != null &&
                    this.PersonId.Equals(input.PersonId))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.ApiKey != null)
                    hashCode = hashCode * 59 + this.ApiKey.GetHashCode();
                if (this.FacesUuids != null)
                    hashCode = hashCode * 59 + this.FacesUuids.GetHashCode();
                if (this.PersonId != null)
                    hashCode = hashCode * 59 + this.PersonId.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
